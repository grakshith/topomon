{"version":3,"sources":["webpack:///webpack/runtime/chunk loaded","webpack:///../node_modules/graphology-communities-louvain/index.js","webpack:///../node_modules/graphology-components/index.js","webpack:///../node_modules/graphology-components/node_modules/graphology-utils/is-graph.js","webpack:///../node_modules/graphology-indices/neighborhood/louvain.js","webpack:///../node_modules/graphology-layout-forceatlas2/index.js","webpack:///../node_modules/graphology-layout-forceatlas2/iterate.js","webpack:///../node_modules/mnemonist/sparse-map.js","webpack:///../node_modules/mnemonist/sparse-queue-set.js","webpack:///../node_modules/mnemonist/utils/typed-arrays.js","webpack:///../node_modules/obliterator/iterator.js","webpack:///./components.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/node module decorator","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"names":["deferred","defaults","isGraph","inferType","SparseMap","SparseQueueSet","createRandomIndex","indices","UndirectedLouvainIndex","DirectedLouvainIndex","DEFAULTS","attributes","community","weight","fastLocalMoves","randomWalk","resolution","rng","Math","random","weighted","addWeightToCommunity","map","currentWeight","get","set","tieBreaker","bestCommunity","currentCommunity","targetCommunity","delta","bestDelta","abs","undirectedLouvain","detailed","graph","options","queue","start","end","ci","ri","s","i","j","l","degree","targetCommunityDegree","localMoves","currentMoves","index","keepDendrogram","randomIndex","moveWasMade","localMoveWasMade","communities","Float64Array","C","deltaComputations","nodesVisited","moves","enqueue","size","dequeue","clear","belongings","starts","neighborhood","weights","fastDeltaWithOwnCommunity","dense","vals","fastDelta","isolate","move","push","zoomOut","directedLouvain","offset","out","inDegree","outDegree","offsets","deltaWithOwnCommunity","louvain","assign","Error","type","c","forEachNode","node","setNodeAttribute","count","order","dendrogram","level","modularity","NaN","results","collect","output","fn","bind","module","exports","extend","connectedComponents","nodes","component","n1","seen","Set","components","stack","length","has","pop","add","neighbors","largestConnectedComponent","remaining","largestComponent","stronglyConnectedComponents","vertex","P","S","preorder","Map","assigned","DFS","neighbor","neighborOrder","outNeighbors","concat","undirectedNeighbors","k","n","value","addUndirectedEdgeWithKey","dropNode","multi","typed","INSPECT","Symbol","for","weightAttribute","selfLoopCount","NeighborhoodPointerArray","getPointerArray","NodesPointerArray","WeightsArray","this","M","E","U","Array","loops","mapping","counts","unused","totalWeights","ids","self","undirectedDegree","forEachEdge","edge","attr","source","target","isNaN","getWeight","startSource","startTarget","slice","totalInWeights","totalOutWeights","prototype","newCommunity","nowEmpty","computeNodeDegree","o","expensiveIsolate","expensiveMove","m","cj","data","adj","currentLevel","nextLevel","inducedGraph","newLabels","N","internalWeights","Q","M2","pow","targetCommunityTotalWeight","bounds","project","projection","forEach","from","arguments","prop","proxy","Object","defineProperty","enumerable","key","inBounds","outBounds","projectIn","projectOut","computeNodeInDegree","computeNodeOutDegree","inAdj","outAdj","targetCommunityTotalInWeight","targetCommunityTotalOutWeight","iterate","helpers","DEFAULT_SETTINGS","abstractSynchronousLayout","params","iterations","settings","validationError","validateSettings","message","matrices","graphToByteArrays","edges","collectLayoutChanges","assignLayoutChanges","synchronousLayout","inferSettings","barnesHutOptimize","strongGravityMode","gravity","scalingRatio","slowDown","log","PPN","NodeMatrix","EdgeMatrix","r","n2","rn","e","w","g","outboundAttCompensation","coefficient","xDist","yDist","ewc","distance","factor","force","swinging","traction","nodespeed","newX","newY","adjustSizes","thetaSquared","barnesHutTheta","RegionMatrix","outboundAttractionDistribution","q","q2","subdivisionAttempts","minX","Infinity","maxX","minY","maxY","min","max","dx","dy","PPR","sqrt","edgeWeightInfluence","linLogMode","Iterator","Values","ByteArray","sparse","member","delete","callback","scope","call","keys","item","done","values","entries","iterator","inspect","constructor","name","capacity","MAX_8BIT_INTEGER","MAX_16BIT_INTEGER","MAX_32BIT_INTEGER","MAX_SIGNED_8BIT_INTEGER","MAX_SIGNED_16BIT_INTEGER","MAX_SIGNED_32BIT_INTEGER","maxIndex","Uint8Array","Uint16Array","Uint32Array","getSignedPointerArray","Int8Array","Int16Array","Int32Array","getNumberType","sign","TYPE_PRIORITY","Float32Array","getMinimalRepresentation","array","getter","p","t","v","maxType","maxPriority","isTypedArray","ArrayBuffer","isView","next","writable","step","_next","of","args","empty","is","document","body","innerHTML","mainContainer","getElementById","UndirectedGraph","mergeEdge","d","log2","h","mergeNode","getNodeAttributes","opposite","biggerCommunities","sort","a","b","cellWidth","offsetWidth","containers","_","container","createElement","style","width","left","top","floor","className","appendChild","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","id","loaded","__webpack_modules__","O","result","chunkIds","priority","notFulfilled","fulfilled","every","splice","definition","globalThis","Function","window","obj","hasOwnProperty","toStringTag","nmd","paths","children","installedChunks","160","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","__webpack_exports__"],"mappings":"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","file":"components.bundle.js","sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tresult = fn();\n\t\t}\n\t}\n\treturn result;\n};","/**\n * Graphology Louvain Algorithm\n * =============================\n *\n * JavaScript implementation of the famous Louvain community detection\n * algorithm for graphology.\n *\n * [Articles]\n * M. E. J. Newman, « Modularity and community structure in networks »,\n * Proc. Natl. Acad. Sci. USA, vol. 103, no 23,‎ 2006, p. 8577–8582\n * https://dx.doi.org/10.1073%2Fpnas.0601602103\n *\n * Newman, M. E. J. « Community detection in networks: Modularity optimization\n * and maximum likelihood are equivalent ». Physical Review E, vol. 94, no 5,\n * novembre 2016, p. 052315. arXiv.org, doi:10.1103/PhysRevE.94.052315.\n * https://arxiv.org/pdf/1606.02319.pdf\n *\n * Blondel, Vincent D., et al. « Fast unfolding of communities in large\n * networks ». Journal of Statistical Mechanics: Theory and Experiment,\n * vol. 2008, no 10, octobre 2008, p. P10008. DOI.org (Crossref),\n * doi:10.1088/1742-5468/2008/10/P10008.\n * https://arxiv.org/pdf/0803.0476.pdf\n *\n * Nicolas Dugué, Anthony Perez. Directed Louvain: maximizing modularity in\n * directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784\n * https://hal.archives-ouvertes.fr/hal-01231784\n *\n * R. Lambiotte, J.-C. Delvenne and M. Barahona. Laplacian Dynamics and\n * Multiscale Modular Structure in Networks,\n * doi:10.1109/TNSE.2015.2391998.\n * https://arxiv.org/abs/0812.1770\n *\n * Traag, V. A., et al. « From Louvain to Leiden: Guaranteeing Well-Connected\n * Communities ». Scientific Reports, vol. 9, no 1, décembre 2019, p. 5233.\n * DOI.org (Crossref), doi:10.1038/s41598-019-41695-z.\n * https://arxiv.org/abs/1810.08473\n */\nvar defaults = require('lodash/defaultsDeep'),\n    isGraph = require('graphology-utils/is-graph'),\n    inferType = require('graphology-utils/infer-type'),\n    SparseMap = require('mnemonist/sparse-map'),\n    SparseQueueSet = require('mnemonist/sparse-queue-set'),\n    createRandomIndex = require('pandemonium/random-index').createRandomIndex;\n\nvar indices = require('graphology-indices/neighborhood/louvain');\n\nvar UndirectedLouvainIndex = indices.UndirectedLouvainIndex,\n    DirectedLouvainIndex = indices.DirectedLouvainIndex;\n\nvar DEFAULTS = {\n  attributes: {\n    community: 'community',\n    weight: 'weight'\n  },\n  fastLocalMoves: true,\n  randomWalk: true,\n  resolution: 1,\n  rng: Math.random,\n  weighted: false\n};\n\nfunction addWeightToCommunity(map, community, weight) {\n  var currentWeight = map.get(community);\n\n  if (typeof currentWeight === 'undefined')\n    currentWeight = 0;\n\n  currentWeight += weight;\n\n  map.set(community, currentWeight);\n}\n\nvar EPSILON = 1e-10;\n\nfunction tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta) {\n  if (Math.abs(delta - bestDelta) < EPSILON) {\n    if (bestCommunity === currentCommunity) {\n      return false;\n    }\n    else {\n      return targetCommunity > bestCommunity;\n    }\n  }\n  else if (delta > bestDelta) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction undirectedLouvain(detailed, graph, options) {\n  var index = new UndirectedLouvainIndex(graph, {\n    attributes: {\n      weight: options.attributes.weight\n    },\n    keepDendrogram: detailed,\n    resolution: options.resolution,\n    weighted: options.weighted\n  });\n\n  var randomIndex = createRandomIndex(options.rng);\n\n  // State variables\n  var moveWasMade = true,\n      localMoveWasMade = true;\n\n  // Communities\n  var currentCommunity, targetCommunity;\n  var communities = new SparseMap(Float64Array, index.C);\n\n  // Traversal\n  var queue,\n      start,\n      end,\n      weight,\n      ci,\n      ri,\n      s,\n      i,\n      j,\n      l;\n\n  // Metrics\n  var degree,\n      targetCommunityDegree;\n\n  // Moves\n  var bestCommunity,\n      bestDelta,\n      deltaIsBetter,\n      delta;\n\n  // Details\n  var deltaComputations = 0,\n      nodesVisited = 0,\n      moves = [],\n      localMoves,\n      currentMoves;\n\n  if (options.fastLocalMoves)\n    queue = new SparseQueueSet(index.C);\n\n  while (moveWasMade) {\n    l = index.C;\n\n    moveWasMade = false;\n    localMoveWasMade = true;\n\n    if (options.fastLocalMoves) {\n      currentMoves = 0;\n\n      // Traversal of the graph\n      ri = options.randomWalk ? randomIndex(l) : 0;\n\n      for (s = 0; s < l; s++, ri++) {\n        i = ri % l;\n        queue.enqueue(i);\n      }\n\n      while (queue.size !== 0) {\n        i = queue.dequeue();\n        nodesVisited++;\n\n        degree = 0;\n        communities.clear();\n\n        currentCommunity = index.belongings[i];\n\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        // Traversing neighbors\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          weight = index.weights[start];\n\n          targetCommunity = index.belongings[j];\n\n          // Incrementing metrics\n          degree += weight;\n          addWeightToCommunity(communities, targetCommunity, weight);\n        }\n\n        // Finding best community to move to\n        bestDelta = index.fastDeltaWithOwnCommunity(\n          i,\n          degree,\n          communities.get(currentCommunity) || 0,\n          currentCommunity\n        );\n        bestCommunity = currentCommunity;\n\n        for (ci = 0; ci < communities.size; ci++) {\n          targetCommunity = communities.dense[ci];\n\n          if (targetCommunity === currentCommunity)\n            continue;\n\n          targetCommunityDegree = communities.vals[ci];\n\n          deltaComputations++;\n\n          delta = index.fastDelta(\n            i,\n            degree,\n            targetCommunityDegree,\n            targetCommunity\n          );\n\n          deltaIsBetter = tieBreaker(\n            bestCommunity,\n            currentCommunity,\n            targetCommunity,\n            delta,\n            bestDelta\n          );\n\n          if (deltaIsBetter) {\n            bestDelta = delta;\n            bestCommunity = targetCommunity;\n          }\n        }\n\n        // Should we move the node?\n        if (bestDelta < 0) {\n\n          // NOTE: this is to allow nodes to move back to their own singleton\n          // This code however only deals with modularity (e.g. the condition\n          // about bestDelta < 0, which is the delta for moving back to\n          // singleton wrt. modularity). Indeed, rarely, the Louvain\n          // algorithm can produce such cases when a node would be better in\n          // a singleton that in its own community when considering self loops\n          // or a resolution != 1. In this case, delta with your own community\n          // is indeed less than 0. To handle different metrics, one should\n          // consider computing the delta for going back to singleton because\n          // it might not be 0.\n          bestCommunity = index.isolate(i, degree);\n\n          // If the node was already in a singleton community, we don't consider\n          // a move was made\n          if (bestCommunity === currentCommunity)\n            continue;\n        }\n        else {\n\n          // If no move was made, we continue to next node\n          if (bestCommunity === currentCommunity) {\n            continue;\n          }\n          else {\n\n            // Actually moving the node to a new community\n            index.move(i, degree, bestCommunity);\n          }\n        }\n\n        moveWasMade = true;\n        currentMoves++;\n\n        // Adding neighbors from other communities to the queue\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          targetCommunity = index.belongings[j];\n\n          if (targetCommunity !== bestCommunity)\n            queue.enqueue(j);\n        }\n      }\n\n      moves.push(currentMoves);\n    }\n    else {\n\n      localMoves = [];\n      moves.push(localMoves);\n\n      // Traditional Louvain iterative traversal of the graph\n      while (localMoveWasMade) {\n\n        localMoveWasMade = false;\n        currentMoves = 0;\n\n        ri = options.randomWalk ? randomIndex(l) : 0;\n\n        for (s = 0; s < l; s++, ri++) {\n          i = ri % l;\n\n          nodesVisited++;\n\n          degree = 0;\n          communities.clear();\n\n          currentCommunity = index.belongings[i];\n\n          start = index.starts[i];\n          end = index.starts[i + 1];\n\n          // Traversing neighbors\n          for (; start < end; start++) {\n            j = index.neighborhood[start];\n            weight = index.weights[start];\n\n            targetCommunity = index.belongings[j];\n\n            // Incrementing metrics\n            degree += weight;\n            addWeightToCommunity(communities, targetCommunity, weight);\n          }\n\n          // Finding best community to move to\n          bestDelta = index.fastDeltaWithOwnCommunity(\n            i,\n            degree,\n            communities.get(currentCommunity) || 0,\n            currentCommunity\n          );\n          bestCommunity = currentCommunity;\n\n          for (ci = 0; ci < communities.size; ci++) {\n            targetCommunity = communities.dense[ci];\n\n            if (targetCommunity === currentCommunity)\n              continue;\n\n            targetCommunityDegree = communities.vals[ci];\n\n            deltaComputations++;\n\n            delta = index.fastDelta(\n              i,\n              degree,\n              targetCommunityDegree,\n              targetCommunity\n            );\n\n            deltaIsBetter = tieBreaker(\n              bestCommunity,\n              currentCommunity,\n              targetCommunity,\n              delta,\n              bestDelta\n            );\n\n            if (deltaIsBetter) {\n              bestDelta = delta;\n              bestCommunity = targetCommunity;\n            }\n          }\n\n          // Should we move the node?\n          if (bestDelta < 0) {\n\n            // NOTE: this is to allow nodes to move back to their own singleton\n            // This code however only deals with modularity (e.g. the condition\n            // about bestDelta < 0, which is the delta for moving back to\n            // singleton wrt. modularity). Indeed, rarely, the Louvain\n            // algorithm can produce such cases when a node would be better in\n            // a singleton that in its own community when considering self loops\n            // or a resolution != 1. In this case, delta with your own community\n            // is indeed less than 0. To handle different metrics, one should\n            // consider computing the delta for going back to singleton because\n            // it might not be 0.\n            bestCommunity = index.isolate(i, degree);\n\n            // If the node was already in a singleton community, we don't consider\n            // a move was made\n            if (bestCommunity === currentCommunity)\n              continue;\n          }\n          else {\n\n            // If no move was made, we continue to next node\n            if (bestCommunity === currentCommunity) {\n              continue;\n            }\n            else {\n\n              // Actually moving the node to a new community\n              index.move(i, degree, bestCommunity);\n            }\n          }\n\n          localMoveWasMade = true;\n          currentMoves++;\n        }\n\n        localMoves.push(currentMoves);\n\n        moveWasMade = localMoveWasMade || moveWasMade;\n      }\n    }\n\n    // We continue working on the induced graph\n    if (moveWasMade)\n      index.zoomOut();\n  }\n\n  var results = {\n    index: index,\n    deltaComputations: deltaComputations,\n    nodesVisited: nodesVisited,\n    moves: moves\n  };\n\n  return results;\n}\n\nfunction directedLouvain(detailed, graph, options) {\n  var index = new DirectedLouvainIndex(graph, {\n    attributes: {\n      weight: options.attributes.weight\n    },\n    keepDendrogram: detailed,\n    resolution: options.resolution,\n    weighted: options.weighted\n  });\n\n  var randomIndex = createRandomIndex(options.rng);\n\n  // State variables\n  var moveWasMade = true,\n      localMoveWasMade = true;\n\n  // Communities\n  var currentCommunity, targetCommunity;\n  var communities = new SparseMap(Float64Array, index.C);\n\n  // Traversal\n  var queue,\n      start,\n      end,\n      offset,\n      out,\n      weight,\n      ci,\n      ri,\n      s,\n      i,\n      j,\n      l;\n\n  // Metrics\n  var inDegree,\n      outDegree,\n      targetCommunityDegree;\n\n  // Moves\n  var bestCommunity,\n      bestDelta,\n      deltaIsBetter,\n      delta;\n\n  // Details\n  var deltaComputations = 0,\n      nodesVisited = 0,\n      moves = [],\n      localMoves,\n      currentMoves;\n\n  if (options.fastLocalMoves)\n    queue = new SparseQueueSet(index.C);\n\n  while (moveWasMade) {\n    l = index.C;\n\n    moveWasMade = false;\n    localMoveWasMade = true;\n\n    if (options.fastLocalMoves) {\n      currentMoves = 0;\n\n      // Traversal of the graph\n      ri = options.randomWalk ? randomIndex(l) : 0;\n\n      for (s = 0; s < l; s++, ri++) {\n        i = ri % l;\n        queue.enqueue(i);\n      }\n\n      while (queue.size !== 0) {\n        i = queue.dequeue();\n        nodesVisited++;\n\n        inDegree = 0;\n        outDegree = 0;\n        communities.clear();\n\n        currentCommunity = index.belongings[i];\n\n        start = index.starts[i];\n        end = index.starts[i + 1];\n        offset = index.offsets[i];\n\n        // Traversing neighbors\n        for (; start < end; start++) {\n          out = start < offset;\n          j = index.neighborhood[start];\n          weight = index.weights[start];\n\n          targetCommunity = index.belongings[j];\n\n          // Incrementing metrics\n          if (out)\n            outDegree += weight;\n          else\n            inDegree += weight;\n\n          addWeightToCommunity(communities, targetCommunity, weight);\n        }\n\n        // Finding best community to move to\n        bestDelta = index.deltaWithOwnCommunity(\n          i,\n          inDegree,\n          outDegree,\n          communities.get(currentCommunity) || 0,\n          currentCommunity\n        );\n        bestCommunity = currentCommunity;\n\n        for (ci = 0; ci < communities.size; ci++) {\n          targetCommunity = communities.dense[ci];\n\n          if (targetCommunity === currentCommunity)\n            continue;\n\n          targetCommunityDegree = communities.vals[ci];\n\n          deltaComputations++;\n\n          delta = index.delta(\n            i,\n            inDegree,\n            outDegree,\n            targetCommunityDegree,\n            targetCommunity\n          );\n\n          deltaIsBetter = tieBreaker(\n            bestCommunity,\n            currentCommunity,\n            targetCommunity,\n            delta,\n            bestDelta\n          );\n\n          if (deltaIsBetter) {\n            bestDelta = delta;\n            bestCommunity = targetCommunity;\n          }\n        }\n\n        // Should we move the node?\n        if (bestDelta < 0) {\n\n          // NOTE: this is to allow nodes to move back to their own singleton\n          // This code however only deals with modularity (e.g. the condition\n          // about bestDelta < 0, which is the delta for moving back to\n          // singleton wrt. modularity). Indeed, rarely, the Louvain\n          // algorithm can produce such cases when a node would be better in\n          // a singleton that in its own community when considering self loops\n          // or a resolution != 1. In this case, delta with your own community\n          // is indeed less than 0. To handle different metrics, one should\n          // consider computing the delta for going back to singleton because\n          // it might not be 0.\n          bestCommunity = index.isolate(i, inDegree, outDegree);\n\n          // If the node was already in a singleton community, we don't consider\n          // a move was made\n          if (bestCommunity === currentCommunity)\n            continue;\n        }\n        else {\n\n          // If no move was made, we continue to next node\n          if (bestCommunity === currentCommunity) {\n            continue;\n          }\n          else {\n\n            // Actually moving the node to a new community\n            index.move(i, inDegree, outDegree, bestCommunity);\n          }\n        }\n\n        moveWasMade = true;\n        currentMoves++;\n\n        // Adding neighbors from other communities to the queue\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          targetCommunity = index.belongings[j];\n\n          if (targetCommunity !== bestCommunity)\n            queue.enqueue(j);\n        }\n      }\n\n      moves.push(currentMoves);\n    }\n    else {\n\n      localMoves = [];\n      moves.push(localMoves);\n\n      // Traditional Louvain iterative traversal of the graph\n      while (localMoveWasMade) {\n\n        localMoveWasMade = false;\n        currentMoves = 0;\n\n        ri = options.randomWalk ? randomIndex(l) : 0;\n\n        for (s = 0; s < l; s++, ri++) {\n          i = ri % l;\n\n          nodesVisited++;\n\n          inDegree = 0;\n          outDegree = 0;\n          communities.clear();\n\n          currentCommunity = index.belongings[i];\n\n          start = index.starts[i];\n          end = index.starts[i + 1];\n          offset = index.offsets[i];\n\n          // Traversing neighbors\n          for (; start < end; start++) {\n            out = start < offset;\n            j = index.neighborhood[start];\n            weight = index.weights[start];\n\n            targetCommunity = index.belongings[j];\n\n            // Incrementing metrics\n            if (out)\n              outDegree += weight;\n            else\n              inDegree += weight;\n\n            addWeightToCommunity(communities, targetCommunity, weight);\n          }\n\n          // Finding best community to move to\n          bestDelta = index.deltaWithOwnCommunity(\n            i,\n            inDegree,\n            outDegree,\n            communities.get(currentCommunity) || 0,\n            currentCommunity\n          );\n          bestCommunity = currentCommunity;\n\n          for (ci = 0; ci < communities.size; ci++) {\n            targetCommunity = communities.dense[ci];\n\n            if (targetCommunity === currentCommunity)\n              continue;\n\n            targetCommunityDegree = communities.vals[ci];\n\n            deltaComputations++;\n\n            delta = index.delta(\n              i,\n              inDegree,\n              outDegree,\n              targetCommunityDegree,\n              targetCommunity\n            );\n\n            deltaIsBetter = tieBreaker(\n              bestCommunity,\n              currentCommunity,\n              targetCommunity,\n              delta,\n              bestDelta\n            );\n\n            if (deltaIsBetter) {\n              bestDelta = delta;\n              bestCommunity = targetCommunity;\n            }\n          }\n\n          // Should we move the node?\n          if (bestDelta < 0) {\n\n            // NOTE: this is to allow nodes to move back to their own singleton\n            // This code however only deals with modularity (e.g. the condition\n            // about bestDelta < 0, which is the delta for moving back to\n            // singleton wrt. modularity). Indeed, rarely, the Louvain\n            // algorithm can produce such cases when a node would be better in\n            // a singleton that in its own community when considering self loops\n            // or a resolution != 1. In this case, delta with your own community\n            // is indeed less than 0. To handle different metrics, one should\n            // consider computing the delta for going back to singleton because\n            // it might not be 0.\n            bestCommunity = index.isolate(i, inDegree, outDegree);\n\n            // If the node was already in a singleton community, we don't consider\n            // a move was made\n            if (bestCommunity === currentCommunity)\n              continue;\n          }\n          else {\n\n            // If no move was made, we continue to next node\n            if (bestCommunity === currentCommunity) {\n              continue;\n            }\n            else {\n\n              // Actually moving the node to a new community\n              index.move(i, inDegree, outDegree, bestCommunity);\n            }\n          }\n\n          localMoveWasMade = true;\n          currentMoves++;\n        }\n\n        localMoves.push(currentMoves);\n\n        moveWasMade = localMoveWasMade || moveWasMade;\n      }\n    }\n\n    // We continue working on the induced graph\n    if (moveWasMade)\n      index.zoomOut();\n  }\n\n  var results = {\n    index: index,\n    deltaComputations: deltaComputations,\n    nodesVisited: nodesVisited,\n    moves: moves\n  };\n\n  return results;\n}\n\n/**\n * Function returning the communities mapping of the graph.\n *\n * @param  {boolean} assign             - Assign communities to nodes attributes?\n * @param  {boolean} detailed           - Whether to return detailed information.\n * @param  {Graph}   graph              - Target graph.\n * @param  {object}  options            - Options:\n * @param  {object}    attributes         - Attribute names:\n * @param  {string}      community          - Community node attribute name.\n * @param  {string}      weight             - Weight edge attribute name.\n * @param  {string}    deltaComputation   - Method to use to compute delta computations.\n * @param  {boolean}   fastLocalMoves     - Whether to use the fast local move optimization.\n * @param  {boolean}   randomWalk         - Whether to traverse the graph in random order.\n * @param  {number}    resolution         - Resolution parameter.\n * @param  {function}  rng                - RNG function to use.\n * @param  {boolean}   weighted           - Whether to compute the weighted version.\n * @return {object}\n */\nfunction louvain(assign, detailed, graph, options) {\n  if (!isGraph(graph))\n    throw new Error('graphology-communities-louvain: the given graph is not a valid graphology instance.');\n\n  var type = inferType(graph);\n\n  if (type === 'mixed')\n    throw new Error('graphology-communities-louvain: cannot run the algorithm on a true mixed graph.');\n\n  // Attributes name\n  options = defaults({}, options, DEFAULTS);\n\n  // Empty graph case\n  var c = 0;\n\n  if (graph.size === 0) {\n    if (assign) {\n      graph.forEachNode(function(node) {\n        graph.setNodeAttribute(node, options.attributes.communities, c++);\n      });\n\n      return;\n    }\n\n    var communities = {};\n\n    graph.forEachNode(function(node) {\n      communities[node] = c++;\n    });\n\n    if (!detailed)\n      return communities;\n\n    return {\n      communities: communities,\n      count: graph.order,\n      deltaComputations: 0,\n      dendrogram: null,\n      level: 0,\n      modularity: NaN,\n      moves: null,\n      nodesVisited: 0,\n      resolution: options.resolution\n    };\n  }\n\n  var fn = type === 'undirected' ? undirectedLouvain : directedLouvain;\n\n  var results = fn(detailed, graph, options);\n\n  var index = results.index;\n\n  // Standard output\n  if (!detailed) {\n    if (assign) {\n      index.assign(options.attributes.community);\n      return;\n    }\n\n    return index.collect();\n  }\n\n  // Detailed output\n  var output = {\n    count: index.C,\n    deltaComputations: results.deltaComputations,\n    dendrogram: index.dendrogram,\n    level: index.level,\n    modularity: index.modularity(),\n    moves: results.moves,\n    nodesVisited: results.nodesVisited,\n    resolution: options.resolution\n  };\n\n  if (assign) {\n    index.assign(options.attributes.community);\n    return output;\n  }\n\n  output.communities = index.collect();\n\n  return output;\n}\n\n/**\n * Exporting.\n */\nvar fn = louvain.bind(null, false, false);\nfn.assign = louvain.bind(null, true, false);\nfn.detailed = louvain.bind(null, false, true);\nfn.defaults = DEFAULTS;\n\nmodule.exports = fn;\n","/**\n * Graphology Components\n * ======================\n *\n * Basic connected components-related functions.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar extend = require('@yomguithereal/helpers/extend');\n\n/**\n * Function returning a list of a graph's connected components as arrays\n * of node keys.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nexports.connectedComponents = function(graph) {\n  if (!isGraph(graph))\n    throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  if (!graph.order)\n    return [];\n\n  if (!graph.size)\n    return graph.nodes().map(function(node) {\n      return [node];\n    });\n\n  var seen = new Set();\n  var components = [];\n  var stack = [];\n  var component;\n\n  var nodes = graph.nodes();\n\n  var i, l, node, n1;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n\n    if (seen.has(node))\n      continue;\n\n    component = [];\n    stack.push(node);\n\n    while (stack.length !== 0) {\n      n1 = stack.pop();\n\n      if (seen.has(n1))\n        continue;\n\n      seen.add(n1);\n      component.push(n1);\n\n      extend(stack, graph.neighbors(n1));\n    }\n\n    components.push(component);\n  }\n\n  return components;\n};\n\n/**\n * Function returning the largest component of the given graph.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nexports.largestConnectedComponent = function(graph) {\n  if (!isGraph(graph))\n    throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  if (!graph.order)\n    return [];\n\n  if (!graph.size)\n    return [graph.nodes()[0]];\n\n  var order = graph.order;\n  var remaining;\n\n  var seen = new Set();\n  var largestComponent = [];\n  var stack = [];\n  var component;\n\n  var nodes = graph.nodes();\n\n  var i, l, node, n1;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n\n    if (seen.has(node))\n      continue;\n\n    component = [];\n    stack.push(node);\n\n    while (stack.length !== 0) {\n      n1 = stack.pop();\n\n      if (seen.has(n1))\n        continue;\n\n      seen.add(n1);\n      component.push(n1);\n\n      extend(stack, graph.neighbors(n1));\n    }\n\n    if (component.length > largestComponent.length)\n      largestComponent = component;\n\n    // Early exit condition\n    // NOTE: could be done each time we traverse a node but would complexify\n    remaining = order - seen.size;\n    if (largestComponent.length > remaining)\n      return largestComponent;\n  }\n\n  return largestComponent;\n};\n\n/**\n * Function returning a list of strongly connected components.\n *\n * @param  {Graph} graph - Target directed graph.\n * @return {array}\n */\nexports.stronglyConnectedComponents = function(graph) {\n  if (!isGraph(graph))\n    throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  if (!graph.order)\n    return [];\n\n  if (graph.type === 'undirected')\n    throw new Error('graphology-components: the given graph is undirected');\n\n  var nodes = graph.nodes(),\n      components = [],\n      i, l;\n\n  if (!graph.size) {\n    for (i = 0, l = nodes.length; i < l; i++)\n      components.push([nodes[i]]);\n    return components;\n  }\n\n  var count = 1,\n      P = [],\n      S = [],\n      preorder = new Map(),\n      assigned = new Set(),\n      component,\n      pop,\n      vertex;\n\n  var DFS = function(node) {\n    var neighbor,\n        neighbors = graph.outNeighbors(node).concat(graph.undirectedNeighbors(node)),\n        neighborOrder;\n\n    preorder.set(node, count++);\n    P.push(node);\n    S.push(node);\n\n    for (var k = 0, n = neighbors.length; k < n; k++) {\n      neighbor = neighbors[k];\n\n      if (preorder.has(neighbor)) {\n        neighborOrder = preorder.get(neighbor);\n        if (!assigned.has(neighbor))\n          while (preorder.get(P[P.length - 1]) > neighborOrder)\n            P.pop();\n      }\n      else\n        DFS(neighbor);\n    }\n\n    if (preorder.get(P[P.length - 1]) === preorder.get(node)) {\n      component = [];\n      do {\n        pop = S.pop();\n        component.push(pop);\n        assigned.add(pop);\n      } while (pop !== node);\n      components.push(component);\n      P.pop();\n    }\n  };\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    vertex = nodes[i];\n    if (!assigned.has(vertex))\n      DFS(vertex);\n  }\n\n  return components;\n};\n","/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","/**\n * Graphology Louvain Indices\n * ===========================\n *\n * Undirected & Directed Louvain Index structures used to compute the famous\n * Louvain community detection algorithm.\n *\n * Most of the rationale is explained in `graphology-metrics`.\n *\n * Note that this index shares a lot with the classic Union-Find data\n * structure. It also relies on a unused id stack to make sure we can\n * increase again the number of communites when isolating nodes.\n *\n * [Articles]\n * M. E. J. Newman, « Modularity and community structure in networks »,\n * Proc. Natl. Acad. Sci. USA, vol. 103, no 23,‎ 2006, p. 8577–8582\n * https://dx.doi.org/10.1073%2Fpnas.0601602103\n *\n * Newman, M. E. J. « Community detection in networks: Modularity optimization\n * and maximum likelihood are equivalent ». Physical Review E, vol. 94, no 5,\n * novembre 2016, p. 052315. arXiv.org, doi:10.1103/PhysRevE.94.052315.\n * https://arxiv.org/pdf/1606.02319.pdf\n *\n * Blondel, Vincent D., et al. « Fast unfolding of communities in large\n * networks ». Journal of Statistical Mechanics: Theory and Experiment,\n * vol. 2008, no 10, octobre 2008, p. P10008. DOI.org (Crossref),\n * doi:10.1088/1742-5468/2008/10/P10008.\n * https://arxiv.org/pdf/0803.0476.pdf\n *\n * Nicolas Dugué, Anthony Perez. Directed Louvain: maximizing modularity in\n * directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784\n * https://hal.archives-ouvertes.fr/hal-01231784\n *\n * R. Lambiotte, J.-C. Delvenne and M. Barahona. Laplacian Dynamics and\n * Multiscale Modular Structure in Networks,\n * doi:10.1109/TNSE.2015.2391998.\n * https://arxiv.org/abs/0812.1770\n *\n * [Latex]:\n *\n * Undirected Case:\n * ----------------\n *\n * \\Delta Q=\\bigg{[}\\frac{\\sum^{c}_{in}-(2d_{c}+l)}{2m}-\\bigg{(}\\frac{\\sum^{c}_{tot}-(d+l)}{2m}\\bigg{)}^{2}+\\frac{\\sum^{t}_{in}+(2d_{t}+l)}{2m}-\\bigg{(}\\frac{\\sum^{t}_{tot}+(d+l)}{2m}\\bigg{)}^{2}\\bigg{]}-\\bigg{[}\\frac{\\sum^{c}_{in}}{2m}-\\bigg{(}\\frac{\\sum^{c}_{tot}}{2m}\\bigg{)}^{2}+\\frac{\\sum^{t}_{in}}{2m}-\\bigg{(}\\frac{\\sum^{t}_{tot}}{2m}\\bigg{)}^{2}\\bigg{]}\n * \\Delta Q=\\frac{d_{t}-d_{c}}{m}+\\frac{l\\sum^{c}_{tot}+d\\sum^{c}_{tot}-d^{2}-l^{2}-2dl-l\\sum^{t}_{tot}-d\\sum^{t}_{tot}}{2m^{2}}\n * \\Delta Q=\\frac{d_{t}-d_{c}}{m}+\\frac{(l+d)\\sum^{c}_{tot}-d^{2}-l^{2}-2dl-(l+d)\\sum^{t}_{tot}}{2m^{2}}\n *\n * Directed Case:\n * --------------\n * \\Delta Q_d=\\bigg{[}\\frac{\\sum^{c}_{in}-(d_{c.in}+d_{c.out}+l)}{m}-\\frac{(\\sum^{c}_{tot.in}-(d_{in}+l))(\\sum^{c}_{tot.out}-(d_{out}+l))}{m^{2}}+\\frac{\\sum^{t}_{in}+(d_{t.in}+d_{t.out}+l)}{m}-\\frac{(\\sum^{t}_{tot.in}+(d_{in}+l))(\\sum^{t}_{tot.out}+(d_{out}+l))}{m^{2}}\\bigg{]}-\\bigg{[}\\frac{\\sum^{c}_{in}}{m}-\\frac{\\sum^{c}_{tot.in}\\sum^{c}_{tot.out}}{m^{2}}+\\frac{\\sum^{t}_{in}}{m}-\\frac{\\sum^{t}_{tot.in}\\sum^{t}_{tot.out}}{m^{2}}\\bigg{]}\n *\n * [Notes]:\n * Louvain is a bit unclear on this but delta computation are not derived from\n * Q1 - Q2 but rather between Q when considered node is isolated in its own\n * community versus Q with this node in target community. This is in fact\n * an optimization because the subtract part is constant in the formulae and\n * does not affect delta comparisons.\n */\nvar typed = require('mnemonist/utils/typed-arrays');\n\nvar INSPECT = Symbol.for('nodejs.util.inspect.custom');\n\nvar DEFAULTS = {\n  attributes: {\n    weight: 'weight'\n  },\n  keepDendrogram: false,\n  resolution: 1,\n  weighted: false\n};\n\nfunction UndirectedLouvainIndex(graph, options) {\n\n  // Solving options\n  options = options || {};\n  var attributes = options.attributes || {};\n\n  var keepDendrogram = options.keepDendrogram === true;\n\n  var resolution = typeof options.resolution === 'number' ?\n    options.resolution :\n    DEFAULTS.resolution;\n\n  // Weight getters\n  var weighted = options.weighted === true;\n\n  var weightAttribute = attributes.weight || DEFAULTS.attributes.weight;\n\n  var getWeight = function(attr) {\n    if (!weighted)\n      return 1;\n\n    var weight = attr[weightAttribute];\n\n    if (typeof weight !== 'number' || isNaN(weight))\n      return 1;\n\n    return weight;\n  };\n\n  // Building the index\n  var size = (graph.size - graph.selfLoopCount) * 2;\n\n  var NeighborhoodPointerArray = typed.getPointerArray(size);\n  var NodesPointerArray = typed.getPointerArray(graph.order + 1);\n  // NOTE: this memory optimization can yield overflow deopt when computing deltas\n  var WeightsArray = weighted ? Float64Array : typed.getPointerArray(graph.size * 2);\n\n  // Properties\n  this.C = graph.order;\n  this.M = 0;\n  this.E = size;\n  this.U = 0;\n  this.resolution = resolution;\n  this.level = 0;\n  this.graph = graph;\n  this.nodes = new Array(graph.order);\n  this.keepDendrogram = keepDendrogram;\n\n  // Edge-level\n  this.neighborhood = new NodesPointerArray(size);\n  this.weights = new WeightsArray(size);\n\n  // Node-level\n  this.loops = new WeightsArray(graph.order);\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n  this.belongings = new NodesPointerArray(graph.order);\n  this.dendrogram = [];\n  this.mapping = null;\n\n  // Community-level\n  this.counts = new NodesPointerArray(graph.order);\n  this.unused = new NodesPointerArray(graph.order);\n  this.totalWeights = new WeightsArray(graph.order);\n\n  var ids = {};\n\n  var weight;\n\n  var i = 0,\n      n = 0;\n\n  var self = this;\n\n  graph.forEachNode(function(node) {\n    self.nodes[i] = node;\n\n    // Node map to index\n    ids[node] = i;\n\n    // Initializing starts\n    n += graph.undirectedDegree(node, false);\n    self.starts[i] = n;\n\n    // Belongings\n    self.belongings[i] = i;\n    self.counts[i] = 1;\n    i++;\n  });\n\n  // Single sweep over the edges\n  graph.forEachEdge(function(edge, attr, source, target) {\n    weight = getWeight(attr);\n\n    source = ids[source];\n    target = ids[target];\n\n    self.M += weight;\n\n    // Self loop?\n    if (source === target) {\n      self.totalWeights[source] += weight * 2;\n      self.loops[source] = weight * 2;\n    }\n    else {\n      self.totalWeights[source] += weight;\n      self.totalWeights[target] += weight;\n\n      var startSource = --self.starts[source],\n          startTarget = --self.starts[target];\n\n      self.neighborhood[startSource] = target;\n      self.neighborhood[startTarget] = source;\n\n      self.weights[startSource] = weight;\n      self.weights[startTarget] = weight;\n    }\n  });\n\n  this.starts[i] = this.E;\n\n  if (this.keepDendrogram)\n    this.dendrogram.push(this.belongings.slice());\n  else\n    this.mapping = this.belongings.slice();\n}\n\nUndirectedLouvainIndex.prototype.isolate = function(i, degree) {\n  var currentCommunity = this.belongings[i];\n\n  // The node is already isolated\n  if (this.counts[currentCommunity] === 1)\n    return currentCommunity;\n\n  var newCommunity = this.unused[--this.U];\n\n  var loops = this.loops[i];\n\n  this.totalWeights[currentCommunity] -= degree + loops;\n  this.totalWeights[newCommunity] += degree + loops;\n\n  this.belongings[i] = newCommunity;\n\n  this.counts[currentCommunity]--;\n  this.counts[newCommunity]++;\n\n  return newCommunity;\n};\n\nUndirectedLouvainIndex.prototype.move = function(\n  i,\n  degree,\n  targetCommunity\n) {\n  var currentCommunity = this.belongings[i],\n      loops = this.loops[i];\n\n  this.totalWeights[currentCommunity] -= degree + loops;\n  this.totalWeights[targetCommunity] += degree + loops;\n\n  this.belongings[i] = targetCommunity;\n\n  var nowEmpty = this.counts[currentCommunity]-- === 1;\n  this.counts[targetCommunity]++;\n\n  if (nowEmpty)\n    this.unused[this.U++] = currentCommunity;\n};\n\nUndirectedLouvainIndex.prototype.computeNodeDegree = function(i) {\n  var o, l, weight;\n\n  var degree = 0;\n\n  for (o = this.starts[i], l = this.starts[i + 1]; o < l; o++) {\n    weight = this.weights[o];\n\n    degree += weight;\n  }\n\n  return degree;\n};\n\nUndirectedLouvainIndex.prototype.expensiveIsolate = function(i) {\n  var degree = this.computeNodeDegree(i);\n  return this.isolate(i, degree);\n};\n\nUndirectedLouvainIndex.prototype.expensiveMove = function(i, ci) {\n  var degree = this.computeNodeDegree(i);\n  this.move(i, degree, ci);\n};\n\nUndirectedLouvainIndex.prototype.zoomOut = function() {\n  var inducedGraph = new Array(this.C - this.U),\n      newLabels = {};\n\n  var N = this.nodes.length;\n\n  var C = 0,\n      E = 0;\n\n  var i, j, l, m, n, ci, cj, data, adj;\n\n  // Renumbering communities\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    if (!(ci in newLabels)) {\n      newLabels[ci] = C;\n      inducedGraph[C] = {\n        adj: {},\n        totalWeights: this.totalWeights[ci],\n        internalWeights: 0\n      };\n      C++;\n    }\n\n    // We do this to otpimize the number of lookups in next loop\n    this.belongings[i] = newLabels[ci];\n  }\n\n  // Actualizing dendrogram\n  var currentLevel, nextLevel;\n\n  if (this.keepDendrogram) {\n    currentLevel = this.dendrogram[this.level];\n    nextLevel = new (typed.getPointerArray(C))(N);\n\n    for (i = 0; i < N; i++)\n      nextLevel[i] = this.belongings[currentLevel[i]];\n\n    this.dendrogram.push(nextLevel);\n  }\n  else {\n    for (i = 0; i < N; i++)\n      this.mapping[i] = this.belongings[this.mapping[i]];\n  }\n\n  // Building induced graph matrix\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    data = inducedGraph[ci];\n    adj = data.adj;\n    data.internalWeights += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      n = this.neighborhood[j];\n      cj = this.belongings[n];\n\n      if (ci === cj) {\n        data.internalWeights += this.weights[j];\n        continue;\n      }\n\n      if (!(cj in adj))\n        adj[cj] = 0;\n\n      adj[cj] += this.weights[j];\n    }\n  }\n\n  // Rewriting neighborhood\n  this.C = C;\n\n  n = 0;\n\n  for (ci = 0; ci < C; ci++) {\n    data = inducedGraph[ci];\n    adj = data.adj;\n\n    ci = +ci;\n\n    this.totalWeights[ci] = data.totalWeights;\n    this.loops[ci] = data.internalWeights;\n    this.counts[ci] = 1;\n\n    this.starts[ci] = n;\n    this.belongings[ci] = ci;\n\n    for (cj in adj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = adj[cj];\n\n      E++;\n      n++;\n    }\n  }\n\n  this.starts[C] = E;\n\n  this.E = E;\n  this.U = 0;\n  this.level++;\n\n  return newLabels;\n};\n\nUndirectedLouvainIndex.prototype.modularity = function() {\n  var ci, cj, i, j, m;\n\n  var Q = 0;\n  var M2 = this.M * 2;\n  var internalWeights = new Float64Array(this.C);\n\n  for (i = 0; i < this.C; i++) {\n    ci = this.belongings[i];\n    internalWeights[ci] += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      cj = this.belongings[this.neighborhood[j]];\n\n      if (ci !== cj)\n        continue;\n\n      internalWeights[ci] += this.weights[j];\n    }\n  }\n\n  for (i = 0; i < this.C; i++) {\n    Q += (\n      internalWeights[i] / M2 -\n      Math.pow(this.totalWeights[i] / M2, 2) * this.resolution\n    );\n  }\n\n  return Q;\n};\n\nUndirectedLouvainIndex.prototype.delta = function(i, degree, targetCommunityDegree, targetCommunity) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    (targetCommunityDegree / M) - // NOTE: formula is a bit different here because targetCommunityDegree is passed without * 2\n    (\n      (targetCommunityTotalWeight * degree * this.resolution) /\n      (2 * M * M)\n    )\n  );\n};\n\nUndirectedLouvainIndex.prototype.deltaWithOwnCommunity = function(i, degree, targetCommunityDegree, targetCommunity) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    (targetCommunityDegree / M) - // NOTE: formula is a bit different here because targetCommunityDegree is passed without * 2\n    (\n      ((targetCommunityTotalWeight - degree) * degree * this.resolution) /\n      (2 * M * M)\n    )\n  );\n};\n\n// NOTE: this is just a faster but equivalent version of #.delta\n// It is just off by a constant factor and is just faster to compute\nUndirectedLouvainIndex.prototype.fastDelta = function(i, degree, targetCommunityDegree, targetCommunity) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree -\n    (degree * targetCommunityTotalWeight * this.resolution) / (2 * M)\n  );\n};\n\nUndirectedLouvainIndex.prototype.fastDeltaWithOwnCommunity = function(i, degree, targetCommunityDegree, targetCommunity) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree -\n    (degree * (targetCommunityTotalWeight - degree) * this.resolution) / (2 * M)\n  );\n};\n\nUndirectedLouvainIndex.prototype.bounds = function(i) {\n  return [this.starts[i], this.starts[i + 1]];\n};\n\nUndirectedLouvainIndex.prototype.project = function() {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function(node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.starts[i + 1])\n    ).map(function(j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nUndirectedLouvainIndex.prototype.collect = function(level) {\n  if (arguments.length < 1)\n    level = this.level;\n\n  var o = {};\n\n  var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;\n\n  var i, l;\n\n  for (i = 0, l = mapping.length; i < l; i++)\n    o[this.nodes[i]] = mapping[i];\n\n  return o;\n};\n\nUndirectedLouvainIndex.prototype.assign = function(prop, level) {\n  if (arguments.length < 2)\n    level = this.level;\n\n  var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;\n\n  var i, l;\n\n  for (i = 0, l = mapping.length; i < l; i++)\n    this.graph.setNodeAttribute(this.nodes[i], prop, mapping[i]);\n};\n\nUndirectedLouvainIndex.prototype[INSPECT] = function() {\n  var proxy = {};\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: UndirectedLouvainIndex,\n    enumerable: false\n  });\n\n  proxy.C = this.C;\n  proxy.M = this.M;\n  proxy.E = this.E;\n  proxy.U = this.U;\n  proxy.resolution = this.resolution;\n  proxy.level = this.level;\n  proxy.nodes = this.nodes;\n  proxy.starts = this.starts.slice(0, proxy.C + 1);\n\n  var eTruncated = ['neighborhood', 'weights'];\n  var cTruncated = ['counts', 'loops', 'belongings', 'totalWeights'];\n\n  var self = this;\n\n  eTruncated.forEach(function(key) {\n    proxy[key] = self[key].slice(0, proxy.E);\n  });\n\n  cTruncated.forEach(function(key) {\n    proxy[key] = self[key].slice(0, proxy.C);\n  });\n\n  proxy.unused = this.unused.slice(0, this.U);\n\n  if (this.keepDendrogram)\n    proxy.dendrogram = this.dendrogram;\n  else\n    proxy.mapping = this.mapping;\n\n  return proxy;\n};\n\nfunction DirectedLouvainIndex(graph, options) {\n\n  // Solving options\n  options = options || {};\n  var attributes = options.attributes || {};\n\n  var keepDendrogram = options.keepDendrogram === true;\n\n  var resolution = typeof options.resolution === 'number' ?\n    options.resolution :\n    DEFAULTS.resolution;\n\n  // Weight getters\n  var weighted = options.weighted === true;\n\n  var weightAttribute = attributes.weight || DEFAULTS.attributes.weight;\n\n  var getWeight = function(attr) {\n    if (!weighted)\n      return 1;\n\n    var weight = attr[weightAttribute];\n\n    if (typeof weight !== 'number' || isNaN(weight))\n      return 1;\n\n    return weight;\n  };\n\n  // Building the index\n  var size = (graph.size - graph.selfLoopCount) * 2;\n\n  var NeighborhoodPointerArray = typed.getPointerArray(size);\n  var NodesPointerArray = typed.getPointerArray(graph.order + 1);\n  // NOTE: this memory optimization can yield overflow deopt when computing deltas\n  var WeightsArray = weighted ? Float64Array : typed.getPointerArray(graph.size * 2);\n\n  // Properties\n  this.C = graph.order;\n  this.M = 0;\n  this.E = size;\n  this.U = 0;\n  this.resolution = resolution;\n  this.level = 0;\n  this.graph = graph;\n  this.nodes = new Array(graph.order);\n  this.keepDendrogram = keepDendrogram;\n\n  // Edge-level\n  // NOTE: edges are stored out then in, in this order\n  this.neighborhood = new NodesPointerArray(size);\n  this.weights = new WeightsArray(size);\n\n  // Node-level\n  this.loops = new WeightsArray(graph.order);\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n  this.offsets = new NeighborhoodPointerArray(graph.order);\n  this.belongings = new NodesPointerArray(graph.order);\n  this.dendrogram = [];\n\n  // Community-level\n  this.counts = new NodesPointerArray(graph.order);\n  this.unused = new NodesPointerArray(graph.order);\n  this.totalInWeights = new WeightsArray(graph.order);\n  this.totalOutWeights = new WeightsArray(graph.order);\n\n  var ids = {};\n\n  var weight;\n\n  var i = 0,\n      n = 0;\n\n  var self = this;\n\n  graph.forEachNode(function(node) {\n    self.nodes[i] = node;\n\n    // Node map to index\n    ids[node] = i;\n\n    // Initializing starts & offsets\n    n += graph.outDegree(node, false);\n    self.starts[i] = n;\n\n    n += graph.inDegree(node, false);\n    self.offsets[i] = n;\n\n    // Belongings\n    self.belongings[i] = i;\n    self.counts[i] = 1;\n    i++;\n  });\n\n  // Single sweep over the edges\n  graph.forEachEdge(function(edge, attr, source, target) {\n    weight = getWeight(attr);\n\n    source = ids[source];\n    target = ids[target];\n\n    self.M += weight;\n\n    // Self loop?\n    if (source === target) {\n      self.loops[source] += weight;\n      self.totalInWeights[source] += weight;\n      self.totalOutWeights[source] += weight;\n    }\n    else {\n      self.totalOutWeights[source] += weight;\n      self.totalInWeights[target] += weight;\n\n      var startSource = --self.starts[source],\n          startTarget = --self.offsets[target];\n\n      self.neighborhood[startSource] = target;\n      self.neighborhood[startTarget] = source;\n\n      self.weights[startSource] = weight;\n      self.weights[startTarget] = weight;\n    }\n  });\n\n  this.starts[i] = this.E;\n\n  if (this.keepDendrogram)\n    this.dendrogram.push(this.belongings.slice());\n  else\n    this.mapping = this.belongings.slice();\n}\n\nDirectedLouvainIndex.prototype.bounds = UndirectedLouvainIndex.prototype.bounds;\n\nDirectedLouvainIndex.prototype.inBounds = function(i) {\n  return [this.offsets[i], this.starts[i + 1]];\n};\n\nDirectedLouvainIndex.prototype.outBounds = function(i) {\n  return [this.starts[i], this.offsets[i]];\n};\n\nDirectedLouvainIndex.prototype.project = UndirectedLouvainIndex.prototype.project;\n\nDirectedLouvainIndex.prototype.projectIn = function() {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function(node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.offsets[i], self.starts[i + 1])\n    ).map(function(j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nDirectedLouvainIndex.prototype.projectOut = function() {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function(node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.offsets[i])\n    ).map(function(j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nDirectedLouvainIndex.prototype.isolate = function(i, inDegree, outDegree) {\n  var currentCommunity = this.belongings[i];\n\n  // The node is already isolated\n  if (this.counts[currentCommunity] === 1)\n    return currentCommunity;\n\n  var newCommunity = this.unused[--this.U];\n\n  var loops = this.loops[i];\n\n  this.totalInWeights[currentCommunity] -= inDegree + loops;\n  this.totalInWeights[newCommunity] += inDegree + loops;\n\n  this.totalOutWeights[currentCommunity] -= outDegree + loops;\n  this.totalOutWeights[newCommunity] += outDegree + loops;\n\n  this.belongings[i] = newCommunity;\n\n  this.counts[currentCommunity]--;\n  this.counts[newCommunity]++;\n\n  return newCommunity;\n};\n\nDirectedLouvainIndex.prototype.move = function(\n  i,\n  inDegree,\n  outDegree,\n  targetCommunity\n) {\n  var currentCommunity = this.belongings[i],\n      loops = this.loops[i];\n\n  this.totalInWeights[currentCommunity] -= inDegree + loops;\n  this.totalInWeights[targetCommunity] += inDegree + loops;\n\n  this.totalOutWeights[currentCommunity] -= outDegree + loops;\n  this.totalOutWeights[targetCommunity] += outDegree + loops;\n\n  this.belongings[i] = targetCommunity;\n\n  var nowEmpty = this.counts[currentCommunity]-- === 1;\n  this.counts[targetCommunity]++;\n\n  if (nowEmpty)\n    this.unused[this.U++] = currentCommunity;\n};\n\nDirectedLouvainIndex.prototype.computeNodeInDegree = function(i) {\n  var o, l, weight;\n\n  var inDegree = 0;\n\n  for (o = this.offsets[i], l = this.starts[i + 1]; o < l; o++) {\n    weight = this.weights[o];\n\n    inDegree += weight;\n  }\n\n  return inDegree;\n};\n\nDirectedLouvainIndex.prototype.computeNodeOutDegree = function(i) {\n  var o, l, weight;\n\n  var outDegree = 0;\n\n  for (o = this.starts[i], l = this.offsets[i]; o < l; o++) {\n    weight = this.weights[o];\n\n    outDegree += weight;\n  }\n\n  return outDegree;\n};\n\nDirectedLouvainIndex.prototype.expensiveMove = function(i, ci) {\n  var inDegree = this.computeNodeInDegree(i),\n      outDegree = this.computeNodeOutDegree(i);\n\n  this.move(i, inDegree, outDegree, ci);\n};\n\nDirectedLouvainIndex.prototype.zoomOut = function() {\n  var inducedGraph = new Array(this.C - this.U),\n      newLabels = {};\n\n  var N = this.nodes.length;\n\n  var C = 0,\n      E = 0;\n\n  var i, j, l, m, n, ci, cj, data, offset, out, adj, inAdj, outAdj;\n\n  // Renumbering communities\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    if (!(ci in newLabels)) {\n      newLabels[ci] = C;\n      inducedGraph[C] = {\n        inAdj: {},\n        outAdj: {},\n        totalInWeights: this.totalInWeights[ci],\n        totalOutWeights: this.totalOutWeights[ci],\n        internalWeights: 0\n      };\n      C++;\n    }\n\n    // We do this to otpimize the number of lookups in next loop\n    this.belongings[i] = newLabels[ci];\n  }\n\n  // Actualizing dendrogram\n  var currentLevel, nextLevel;\n\n  if (this.keepDendrogram) {\n    currentLevel = this.dendrogram[this.level];\n    nextLevel = new (typed.getPointerArray(C))(N);\n\n    for (i = 0; i < N; i++)\n      nextLevel[i] = this.belongings[currentLevel[i]];\n\n    this.dendrogram.push(nextLevel);\n  }\n  else {\n    for (i = 0; i < N; i++)\n      this.mapping[i] = this.belongings[this.mapping[i]];\n  }\n\n  // Building induced graph matrix\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n    offset = this.offsets[i];\n\n    data = inducedGraph[ci];\n    inAdj = data.inAdj;\n    outAdj = data.outAdj;\n    data.internalWeights += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      n = this.neighborhood[j];\n      cj = this.belongings[n];\n      out = j < offset;\n\n      adj = out ? outAdj : inAdj;\n\n      if (ci === cj) {\n        if (out)\n          data.internalWeights += this.weights[j];\n\n        continue;\n      }\n\n      if (!(cj in adj))\n        adj[cj] = 0;\n\n      adj[cj] += this.weights[j];\n    }\n  }\n\n  // Rewriting neighborhood\n  this.C = C;\n\n  n = 0;\n\n  for (ci = 0; ci < C; ci++) {\n    data = inducedGraph[ci];\n    inAdj = data.inAdj;\n    outAdj = data.outAdj;\n\n    ci = +ci;\n\n    this.totalInWeights[ci] = data.totalInWeights;\n    this.totalOutWeights[ci] = data.totalOutWeights;\n    this.loops[ci] = data.internalWeights;\n    this.counts[ci] = 1;\n\n    this.starts[ci] = n;\n    this.belongings[ci] = ci;\n\n    for (cj in outAdj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = outAdj[cj];\n\n      E++;\n      n++;\n    }\n\n    this.offsets[ci] = n;\n\n    for (cj in inAdj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = inAdj[cj];\n\n      E++;\n      n++;\n    }\n  }\n\n  this.starts[C] = E;\n\n  this.E = E;\n  this.U = 0;\n  this.level++;\n\n  return newLabels;\n};\n\nDirectedLouvainIndex.prototype.modularity = function() {\n  var ci, cj, i, j, m;\n\n  var Q = 0;\n  var M = this.M;\n  var internalWeights = new Float64Array(this.C);\n\n  for (i = 0; i < this.C; i++) {\n    ci = this.belongings[i];\n    internalWeights[ci] += this.loops[i];\n\n    for (j = this.starts[i], m = this.offsets[i]; j < m; j++) {\n      cj = this.belongings[this.neighborhood[j]];\n\n      if (ci !== cj)\n        continue;\n\n      internalWeights[ci] += this.weights[j];\n    }\n  }\n\n  for (i = 0; i < this.C; i++)\n    Q += (\n      (internalWeights[i] / M) -\n      (this.totalInWeights[i] * this.totalOutWeights[i] / Math.pow(M, 2)) *\n      this.resolution\n    );\n\n  return Q;\n};\n\nDirectedLouvainIndex.prototype.delta = function(\n  i,\n  inDegree,\n  outDegree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity],\n      targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];\n\n  var loops = this.loops[i];\n\n  inDegree += loops;\n  outDegree += loops;\n\n  return (\n    (targetCommunityDegree / M) -\n    (\n      (\n        (outDegree * targetCommunityTotalInWeight) +\n        (inDegree * targetCommunityTotalOutWeight)\n      ) * this.resolution /\n      (M * M)\n    )\n  );\n};\n\nDirectedLouvainIndex.prototype.deltaWithOwnCommunity = function(\n  i,\n  inDegree,\n  outDegree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity],\n      targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];\n\n  var loops = this.loops[i];\n\n  inDegree += loops;\n  outDegree += loops;\n\n  return (\n    (targetCommunityDegree / M) -\n    (\n      (\n        (outDegree * (targetCommunityTotalInWeight - inDegree)) +\n        (inDegree * (targetCommunityTotalOutWeight - outDegree))\n      ) * this.resolution /\n      (M * M)\n    )\n  );\n};\n\nDirectedLouvainIndex.prototype.collect = UndirectedLouvainIndex.prototype.collect;\nDirectedLouvainIndex.prototype.assign = UndirectedLouvainIndex.prototype.assign;\n\nDirectedLouvainIndex.prototype[INSPECT] = function() {\n  var proxy = {};\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: DirectedLouvainIndex,\n    enumerable: false\n  });\n\n  proxy.C = this.C;\n  proxy.M = this.M;\n  proxy.E = this.E;\n  proxy.U = this.U;\n  proxy.resolution = this.resolution;\n  proxy.level = this.level;\n  proxy.nodes = this.nodes;\n  proxy.starts = this.starts.slice(0, proxy.C + 1);\n\n  var eTruncated = ['neighborhood', 'weights'];\n  var cTruncated = ['counts', 'offsets', 'loops', 'belongings', 'totalInWeights', 'totalOutWeights'];\n\n  var self = this;\n\n  eTruncated.forEach(function(key) {\n    proxy[key] = self[key].slice(0, proxy.E);\n  });\n\n  cTruncated.forEach(function(key) {\n    proxy[key] = self[key].slice(0, proxy.C);\n  });\n\n  proxy.unused = this.unused.slice(0, this.U);\n\n  if (this.keepDendrogram)\n    proxy.dendrogram = this.dendrogram;\n  else\n    proxy.mapping = this.mapping;\n\n  return proxy;\n};\n\nexports.UndirectedLouvainIndex = UndirectedLouvainIndex;\nexports.DirectedLouvainIndex = DirectedLouvainIndex;\n","/**\n * Graphology ForceAtlas2 Layout\n * ==============================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph'),\n    iterate = require('./iterate.js'),\n    helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.iterations, else:\n * @param  {number}          iterations - Number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error('graphology-layout-forceatlas2: the given graph is not a valid graphology instance.');\n\n  if (typeof params === 'number')\n    params = {iterations: params};\n\n  var iterations = params.iterations;\n\n  if (typeof iterations !== 'number')\n    throw new Error('graphology-layout-forceatlas2: invalid number of iterations.');\n\n  if (iterations <= 0)\n    throw new Error('graphology-layout-forceatlas2: you should provide a positive number of iterations.');\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings),\n      validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error('graphology-layout-forceatlas2: ' + validationError.message);\n\n  // Building matrices\n  var matrices = helpers.graphToByteArrays(graph),\n      i;\n\n  // Iterating\n  for (i = 0; i < iterations; i++)\n    iterate(settings, matrices.nodes, matrices.edges);\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrices.nodes);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrices.nodes);\n}\n\n/**\n * Function returning sane layout settings for the given graph.\n *\n * @param  {Graph}  graph - Target graph.\n * @return {object}\n */\nfunction inferSettings(graph) {\n  var order = graph.order;\n\n  return {\n    barnesHutOptimize: order > 2000,\n    strongGravityMode: true,\n    gravity: 0.05,\n    scalingRatio: 10,\n    slowDown: 1 + Math.log(order)\n  };\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\nsynchronousLayout.inferSettings = inferSettings;\n\nmodule.exports = synchronousLayout;\n","/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n    NODE_Y = 1,\n    NODE_DX = 2,\n    NODE_DY = 3,\n    NODE_OLD_DX = 4,\n    NODE_OLD_DY = 5,\n    NODE_MASS = 6,\n    NODE_CONVERGENCE = 7,\n    NODE_SIZE = 8,\n    NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0,\n    EDGE_TARGET = 1,\n    EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0,\n    REGION_CENTER_X = 1,\n    REGION_CENTER_Y = 2,\n    REGION_SIZE = 3,\n    REGION_NEXT_SIBLING = 4,\n    REGION_FIRST_CHILD = 5,\n    REGION_MASS = 6,\n    REGION_MASS_CENTER_X = 7,\n    REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10,\n    PPE = 3,\n    PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n      size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation,\n      coefficient,\n      xDist,\n      yDist,\n      ewc,\n      distance,\n      factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= (order / PPN);\n  }\n\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n\n    // Setting up\n    var minX = Infinity,\n        maxX = -Infinity,\n        minY = Infinity,\n        maxY = -Infinity,\n        q, q2, subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX, dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    }\n    else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            }\n            else {\n\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          }\n          else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            }\n            else {\n\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        }\n        else {\n\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          }\n          else {\n\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              }\n              else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance = (\n            (Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2)) +\n            (Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2))\n          );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n\n            // We treat the region as a single body, and we repulse\n\n            xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0)\n              break; // No next sibling: we have finished the tree\n\n            continue;\n          }\n          else {\n\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n\n        }\n        else {\n\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0)\n            break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  }\n  else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n\n          //-- Anticollision Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] += xDist * factor;\n            NodeMatrix[n2 + NODE_DY] += yDist * factor;\n          }\n          else if (distance < 0) {\n            factor = 100 * coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n        else {\n\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(\n      Math.pow(xDist, 2) + Math.pow(yDist, 2)\n    );\n\n    if (options.strongGravityMode) {\n\n      //-- Strong gravity\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    }\n    else {\n\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient = 1 *\n    (options.outboundAttractionDistribution ?\n      outboundAttCompensation :\n      1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n\n      distance = Math.sqrt(\n        (Math.pow(xDist, 2) + Math.pow(yDist, 2)) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE]\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n            distance /\n            NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n          }\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    }\n    else {\n\n      distance = Math.sqrt(\n        Math.pow(xDist, 2) + Math.pow(yDist, 2)\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n        }\n        else {\n\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n\n  // 5) Apply Forces\n  //-----------------\n  var force,\n      swinging,\n      traction,\n      nodespeed,\n      newX,\n      newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n          Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            NodeMatrix[n + NODE_DX] * MAX_FORCE / force;\n          NodeMatrix[n + NODE_DY] =\n            NodeMatrix[n + NODE_DY] * MAX_FORCE / force;\n        }\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed =\n          0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n  else {\n\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed = NodeMatrix[n + NODE_CONVERGENCE] *\n          Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] =\n          Math.min(1, Math.sqrt(\n            nodespeed *\n            (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n             Math.pow(NodeMatrix[n + NODE_DY], 2)) /\n            (1 + Math.sqrt(swinging))\n          ));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n","/**\n * Mnemonist SparseMap\n * ====================\n *\n * JavaScript sparse map implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseMap.\n *\n * @constructor\n */\nfunction SparseMap(Values, length) {\n  if (arguments.length < 2) {\n    length = Values;\n    Values = Array;\n  }\n\n  var ByteArray = getPointerArray(length);\n\n  // Properties\n  this.size = 0;\n  this.length = length;\n  this.dense = new ByteArray(length);\n  this.sparse = new ByteArray(length);\n  this.vals = new Values(length);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseMap.prototype.clear = function() {\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {SparseMap}\n */\nSparseMap.prototype.has = function(member) {\n  var index = this.sparse[member];\n\n  return (\n    index < this.size &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to get the value associated to a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {any}\n */\nSparseMap.prototype.get = function(member) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member)\n    return this.vals[index];\n\n  return;\n};\n\n/**\n * Method used to set a value into the map.\n *\n * @param  {number} member - Member to set.\n * @param  {any}    value  - Associated value.\n * @return {SparseMap}\n */\nSparseMap.prototype.set = function(member, value) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member) {\n    this.vals[index] = value;\n    return this;\n  }\n\n  this.dense[this.size] = member;\n  this.sparse[member] = this.size;\n  this.vals[this.size] = value;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove a member from the set.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseMap.prototype.delete = function(member) {\n  var index = this.sparse[member];\n\n  if (index >= this.size || this.dense[index] !== member)\n    return false;\n\n  index = this.dense[this.size - 1];\n  this.dense[this.sparse[member]] = index;\n  this.sparse[index] = this.sparse[member];\n  this.size--;\n\n  return true;\n};\n\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseMap.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0; i < this.size; i++)\n    callback.call(scope, this.vals[i], this.dense[i]);\n};\n\n/**\n * Method used to create an iterator over a set's members.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.keys = function() {\n  var size = this.size,\n      dense = this.dense,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = dense[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.values = function() {\n  var size = this.size,\n      values = this.vals,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = values[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.entries = function() {\n  var size = this.size,\n      dense = this.dense,\n      values = this.vals,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = [dense[i], values[i]];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseMap.prototype[Symbol.iterator] = SparseMap.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nSparseMap.prototype.inspect = function() {\n  var proxy = new Map();\n\n  for (var i = 0; i < this.size; i++)\n    proxy.set(this.dense[i], this.vals[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseMap,\n    enumerable: false\n  });\n\n  proxy.length = this.length;\n\n  if (this.vals.constructor !== Array)\n    proxy.type = this.vals.constructor.name;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseMap.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseMap;\n","/**\n * Mnemonist SparseQueueSet\n * =========================\n *\n * JavaScript sparse queue set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseQueueSet.\n *\n * @constructor\n */\nfunction SparseQueueSet(capacity) {\n\n  var ByteArray = getPointerArray(capacity);\n\n  // Properties\n  this.start = 0;\n  this.size = 0;\n  this.capacity = capacity;\n  this.dense = new ByteArray(capacity);\n  this.sparse = new ByteArray(capacity);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseQueueSet.prototype.clear = function() {\n  this.start = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the queue.\n *\n * @param  {number} member - Member to test.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.has = function(member) {\n  if (this.size === 0)\n    return false;\n\n  var index = this.sparse[member];\n\n  var inBounds = (\n    index < this.capacity &&\n    (\n      index >= this.start &&\n      index < this.start + this.size\n    ) ||\n    (\n      index < ((this.start + this.size) % this.capacity)\n    )\n  );\n\n  return (\n    inBounds &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to add a member to the queue.\n *\n * @param  {number} member - Member to add.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.enqueue = function(member) {\n  var index = this.sparse[member];\n\n  if (this.size !== 0) {\n    var inBounds = (\n      index < this.capacity &&\n      (\n        index >= this.start &&\n        index < this.start + this.size\n      ) ||\n      (\n        index < ((this.start + this.size) % this.capacity)\n      )\n    );\n\n    if (inBounds && this.dense[index] === member)\n      return this;\n  }\n\n  index = (this.start + this.size) % this.capacity;\n\n  this.dense[index] = member;\n  this.sparse[member] = index;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove the next member from the queue.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseQueueSet.prototype.dequeue = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start;\n\n  this.size--;\n  this.start++;\n\n  if (this.start === this.capacity)\n    this.start = 0;\n\n  var member = this.dense[index];\n\n  this.sparse[member] = this.capacity;\n\n  return member;\n};\n\n/**\n * Method used to iterate over the queue's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseQueueSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.dense[i], j, this);\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseQueueSet.prototype.values = function() {\n  var dense = this.dense,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = dense[i];\n\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.iterator] = SparseQueueSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nSparseQueueSet.prototype.inspect = function() {\n  var proxy = [];\n\n  this.forEach(function(member) {\n    proxy.push(member);\n  });\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseQueueSet,\n    enumerable: false\n  });\n\n  proxy.capacity = this.capacity;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseQueueSet.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseQueueSet;\n","/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  return Float64Array;\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","import { UndirectedGraph } from \"graphology\";\nimport randomLayout from \"graphology-layout/random\";\nimport forceAtlas2 from \"graphology-layout-forceatlas2\";\nimport louvain from \"graphology-communities-louvain\";\nimport { connectedComponents } from \"graphology-components\";\n\nimport Sigma from \"sigma\";\n\nimport data from \"./resources/toflit.json\";\n\nconst scale = (d: number) => Math.max(2, Math.log2(d) * 1.7);\n\ndocument.body.innerHTML += `\n  <style>\n    .subcontainer {\n      position: absolute;\n      height: 300px;\n      border-right: 1px solid black;\n      border-bottom: 1px solid black;\n    }\n    .subcontainer:nth-child(1),\n    .subcontainer:nth-child(2),\n    .subcontainer:nth-child(3) {\n      border-top: 1px solid black;\n    }\n  </style>\n`;\n\nconst mainContainer = document.getElementById(\"container\") as HTMLElement;\n\nconst graph = new UndirectedGraph();\n\ndata.forEach(({ source, target }) => {\n  graph.mergeEdge(source, target);\n});\n\ngraph.nodes().forEach((node) => {\n  graph.setNodeAttribute(node, \"label\", node);\n  graph.setNodeAttribute(node, \"size\", scale(graph.degree(node)));\n});\n\nconst components = connectedComponents(graph);\n\ncomponents.forEach((component) => {\n  if (component.length < 10) component.forEach((node) => graph.dropNode(node));\n});\n\nconst map: { [key: string]: number } = louvain(graph);\nconst communities: { [key: string]: UndirectedGraph } = {};\n\nfor (const node in map) {\n  const c = map[node];\n\n  if (!(c in communities)) communities[c] = new UndirectedGraph();\n\n  const h = communities[c];\n\n  h.mergeNode(node, graph.getNodeAttributes(node));\n\n  graph.edges(node).forEach((edge) => {\n    const target = graph.opposite(node, edge);\n\n    if (node < target || map[target] !== c) return;\n\n    h.mergeEdge(node, target);\n  });\n}\n\nconst biggerCommunities: Array<UndirectedGraph> = Object.values(communities)\n  .sort((a, b) => b.order - a.order)\n  .slice(0, 6);\n\nconst width = mainContainer.offsetWidth;\n\nconst cellWidth = (width / 3) | 0;\n\nconst containers = biggerCommunities.map((_, i) => {\n  const container = document.createElement(\"div\");\n  container.style.width = `${cellWidth}px`;\n  container.style.left = `${(i % 3) * cellWidth}px`;\n  container.style.top = `${Math.floor(i / 3) * 300}px`;\n  container.className = \"subcontainer\";\n  mainContainer.appendChild(container);\n  return container;\n});\n\nbiggerCommunities.forEach((h, i) => {\n  randomLayout.assign(h);\n  forceAtlas2.assign(h, {\n    iterations: 100,\n    settings: forceAtlas2.inferSettings(h),\n  });\n\n  const container = containers[i];\n\n  new Sigma(h, container);\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t160: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) var result = runtime(__webpack_require__);\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkIds[i]] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [351], () => (__webpack_require__(6830)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"sourceRoot":""}